# Network

## 목차
- [OSI 7계층 & TCP/IP 4계층](#osi-7계층--tcpip-4계층)
- [TCP/IP](#tcpip)
- [IP(인터넷 프로토콜)](#ip인터넷-프로토콜)
- [TCP & UDP](#tcp--udp)
- [3-way handshake & 4-way handshake](#3-way-handshake--4-way-handshake)
- [PORT](#port)
- [DNS](#dns)
- [URI, URL, URN](#uri-url-urn)
- [웹 브라우저 요청 흐름](#웹-브라우저-요청-흐름)
- [HTTP](#http)
## 정리할 것들
- HTTP & HTTPS  
- HTTP GET과 POST 비교  
- 쿠키와 세션의 차이  
- 대칭키 & 공개키  
---

## OSI 7계층 & TCP/IP 4계층
![image](https://user-images.githubusercontent.com/87891581/168009131-3d8a50ae-b638-4f41-9567-300603b98aa4.png)
### 1. OSI 7계층
- 국제 표준화 기구(ISO)에서 개발한 모델로, 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것이다.
- 통신이 일어나는 과정을 단계별로 알 수 있고, 특정한 곳에 이상이 생기면 그 단계만 수정할 수 있기 때문에 편리하다.

**1. 물리 계층(Physical layer)**
> 리피터, 케이블, 허브 등

- 주로 전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송하는 역할을 한다.  

**2. 데이터 링크 계층(Data link layer)**
> 브릿지, 스위치 등

- 물리 계층을 통해 송, 수신되는 정보의 오류와 흐름을 관리하여 안전한 정보의 전달을 수행할 수 있도록 도와주는 역할을 한다.
- MAC 주소를 이용해 통신한다.
- Frame에 MAC 주소를 부여하고 에러검출, 재전송, 흐름 제어를 진행한다.

**3. 네트워크 계층(Network layer)**  
> 라우터, IP

- 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능을 담당한다.
- 라우터를 통해 이동할 경로를 선택하여 IP 주소를 지정하고, 해당 경로에 따라 패킷을 전달해준다.
- 라우팅, 흐름 제어, 오류 제어, 세그먼테이션 등을 수행한다.

**4. 전송 계층(Transport layer)**  
> TCP, UDP

- TCP, UDP 프로토콜을 통해 통신을 활성화 한다. 
  - TCP : 신뢰성, 연결 지향적
  - UDP : 비신뢰성, 비연결성, 실시간
- 포트를 열어두고, 프로그램들이 전송을 할 수 있도록 제공해준다. 
- 이를 통해 양 끝 단의 사용자들이 데이터를 주고 받을 수 있다.

**5. 세션 계층(Session layer)**  
> API, Socket

- 데이터가 통신하기 위한 논리적인 연결을 말한다.
- 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.
- TCP/IP 세션을 만들고 없애는 책임을 지니고 있다.

**6. 표현 계층(Presentation layer)**  
- 데이터 표현에 대한 독립성을 제공하고 암호화하는 역할을 담당한다.
- 해당 데이터가 TEXT인지, 그림인지, GIF인지, JPG인지 등의 구분이 표현 계층이 하는 일이다.
- 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어준다.

**7. 응용 계층(Application layer)**  
> HTTP, FTP 등

- 최종 목적지로, 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.

### 2. TCP/IP 4계층
**1. 네트워크 인터페이스 계층**
- OSI 계층의 물리 계층과 데이터 링크 계층에 해당된다.
- 신뢰성 있는 데이터 전송을 담당한다.
- 물리적인 주소로 MAC을 사용한다.

**2. 인터넷 계층**
- OSI 계층의 네트워크 계층에 해당된다.

**3. 전송 계층**
- OSI 계층의 전송 계층에 해당된다.

**4. 애플리케이션 계층 - HTTP, FTP**
- OSI 계층의 세션 계층, 표현 계층, 응용 계층에 해당된다.
- 다른 계층의 서비스에 접근할 수 있게 하는 애플리케이션을 제공한다.
- 응용프로그램(application)들이 데이터를 교환하기 위해 사용하는 프로토콜을 정의한다.

## TCP/IP
- TCP와 IP 두 가지 프로토콜로 이루어져 있다.
- 데이터가 의도된 목적지에 닿을 수 있도록 보장해주는 통신 규약이다.

## IP(인터넷 프로토콜)
- 컴퓨터 네트워크에서 장치들이 서로를 인식하고 통신을 하기 위해서 사용하는 특수한 번호이다.
- 주로 사용하는 주소는 IPv4(32비트) 주소이며, 시간이 갈수록 IPv4 주소의 부족으로 128비트의 IPv6 주소가 등장했다.
- 지정한 IP 주소(IP Address)에 패킷(Packet)이라는 통신 단위로 데이터 전달
- IP 패킷
  ![image](https://user-images.githubusercontent.com/87891581/147866287-cf9593db-7932-43d7-9edd-c301e02123ce.png)
### 한계점
- 비연결성
    - 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷을 전송한다.
- 비신뢰성
    - 중간에 패킷이 유실될 수 있다.
    - 패킷이 순서가 바뀔 수 있다.
- 프로그램 구분
    - 같은 IP를 사용하는 서버에서 통신하는 애플리케이션을 구분할 수 없다.

## TCP & UDP
- 전송 계층에서 사용하는 프로토콜
### 1. TCP
- 전송 제어 프로토콜(Transmission Control Protocol)
- 신뢰성 있는 데이터 전송을 지원하는 연결 지향형 프로토콜
- 사전에 3-way handshake라는 과정을 통해 통신을 시작하고, 4-way handshake 과정으로 통해 연결을 해제한다.
  - 가상 회선 방식이라고 부른다.
- TCP가 가상 회선 방식을 제공한다는 것은 송신측과 수신측을 연결하여 패킷을 전송하기 위한 논리적 경로를 배정한다는 뜻이다.
- 흐름 제어, 혼잡 제어를 통해 신뢰성을 보장한다. 
  - 흐름 제어
    - 데이터를 송식하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것이다.
    - 송신하는 곳에서 감당이 안되게 많은 데이터를 빠르게 보내 수신하는 곳에서 문제가 발생하는 것을 막는다.
  - 혼잡 제어
    - 네트워크 내의 패킷 수가 넘치지 않게 방지하는 것이다.
    - 정보의 소통량이 과다하면 패킷을 조금만 전송해서 혼잡 붕괴 현상이 발생하는 것을 막는다.
- UDP보다 속도가 느리다.
- 현재는 대부분 TCP 사용  

**TCP/IP 패킷**
![image](https://user-images.githubusercontent.com/87891581/147866498-90715019-50e8-4f3b-b3f3-60b7e731d225.png)

### 2. UDP
- 사용자 데이터그램 프로토콜(User Datagram Protocol)
- 데이터를 데이터그램 단위로 처리하는 비연결형 프로토콜
- 연결을 위해 할당하는 논리적인 경로가 없다.
  - 각각의 패킷은 다른 경로로 전송되고, 독립적으로 처리된다.
  - 순서가 뒤바뀔 수도 있기 때문에 애플리케이션에서 추가 작업이 필요하다.
- 속도가 빠르고 네트워크 부하가 적기 때문에 성능 향상을 위해 UDP의 사용 빈도 증가

## 3-way handshake & 4-way handshake
### 1. 3-way handshake
- TCP/IP 프로토콜로 통신을 진행할 때, 두 종단 간 정확한 데이터 전송을 보장하기 위해 연결을 설정하는 과정이다.

#### 연결 과정
1. 클라이언트는 서버에 적속을 요청하는 SYN 패킷을 보낸다.
2. 서버는 요청 수락 응답으로 ACK 패킷과 클라이언트도 포트를 열어달라는 SYN 패킷을 보낸다.
3. 클라이언트는 이에 대한 수락 응답으로 ACK 패킷을 보내며 가상 연결이 성립된다.

### 2. 4-way handshake
- TCP/IP 프로토콜에서는 3 way handshake로 연결을 설정하고, 4 way handshake로 연결 설정을 해제한다.

#### 연결 과정
1. 클라이언트는 서버에게 연결을 종료하겠다는 FIN 패킷을 보낸다.
2. 서버는 확인했다는 응답으로 ACK 패킷을 보낸다.
   - 이때 모든 데이터를 보내기 위해 CLOSE_WAIT 상태가 된다.
3. 데이터를 모두 보냈다면, 연결을 종료하겠다는 FIN 패킷을 클라이언트에게 보낸다.
4. 클라이언트는 확인했다는 응답으로 ACK 패킷을 보낸다.
  - 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT 상태로 기다린다.
5. 서버는 ACK를 받인 이후 소켓을 닫는다.(Closed)
6. 클라이언트는 TIME_WAIT 상태가 끝나면 소켓을 닫는다.(Closed)

## PORT

- 같은 IP 내에서 프로세스 구분하기 위해 사용한다.
    - 아파트 동 -> IP, 호수 -> PORT
- 0 ~ 65535 할당 가능(2^16)
- 0 ~ 1023 잘 알려진 포트, 사용하지 않는 것이 좋다.
    - FTP - 20, 21
    - TELNET - 23
    - HTTP - 80
    - HTTPS - 443

## DNS
- 도메인 네임 시스템(Domain name System)
- IP 주소를 문자로 표현한 주소를 도메인 네임이라고 한다.
- IP는 기억하기 어렵고, 변경될 수 있기 때문에 사용한다.
- DNS 서버에서 도메인 네임과 매칭되는 IP 주소값을 보유하고 있다.

## URI, URL, URN

### 1. URI

- Uniform Resource Identifier
    - Uniform : 리소스를 식별하는 통일된 방식
    - Resource : 자원, URI로 식별할 수 있는 모든 것(제한 없음)
    - Identifier : 다른 항목과 구분하는데 필요한 정보
- 인터넷에 있는 자원을 나타내는 유일한 주소이다.
- URL과 URN이 URI에 포함된다.
  ![image](https://user-images.githubusercontent.com/87891581/147871549-b5e50fdc-4e0f-46d3-aa44-f413560f6394.png)

### 2. URL과 URN

![image](https://user-images.githubusercontent.com/87891581/147871575-1fbe4958-30f3-45f8-b08d-91c6ff0a46d5.png)

- URL - Locator : 리소스가 있는 위치 지정
- URN - Name : 리소스에 이름을 부여
    - 예 urn:isbn:896077731
- 위치는 변할 수 있지만, 이름은 변하지 않는다.
- URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않음

### 3. URL 문법

`scheme://[userinfo@]host[:port][/path][?query][#fragment]`  
- ex) `https://www.google.com:443/search?q=hello&hl=ko`
- scheme
    - 주로 프로토콜을 사용
    - 프로토콜 : 어떤 방식으로 자원에 접근할 것이가 하는 약속 규칙. 예) http, https, ftp 등
        - https는 http에 보안 추가(HTTP Secure)
- userinfo
    - URL에 사용자 정보를 보항해서 인증
    - 거의 사용하지 않음
- host
    - 호스트명
    - 도메인명 또는 IP 주소를 직접 사용 가능
- port
    - 접속 포트
    - 일반적으로 생략.
    - http는 80포트, https는 443 포트를 주로 사용.
- path
    - 리소스 경로(path)
    - 계층적 구조
    - 예)
        - `/home/file1.jpg`
        - `/members`
- query
    - `key=value` 형태
    - ?로 시작, &로 추가 가능
        - 예) ?keyA = valueA&keyB=valueB
    - query parameter, query string등으로 불림.
    - 문자 형태
- fragment
    - html 내부 북마크 등에 사용
    - 서버에 전송하는 정보 아님

## 웹 브라우저 요청 흐름

<img src="https://user-images.githubusercontent.com/87891581/168077028-da2d1d67-6b73-4a5f-a5c1-98d7c3c3da1c.png" alt="이미지">

1. 클라이언트가 도메인 명(ex. google.com)을 포함하는 URL로 요청한다.
2. DNS 서버에서 도메인 명과 매칭과는 IP 주소를 찾는다.
3. 브라우저는 DNS를 통해 서버의 진짜 주소를 찾음
4. HTTP 프로토콜을 사용하여 HTTP 요청 메세지를 생성한다.
5. TCP/IP 연결을 통해 HTTP 요청이 인터넷을 거쳐 해당 IP 주소의 서버로 전송된다.
6. 서버는 HTTP 프로토콜을 활용하여 적절한 데이터를 찾고, HTTP 응답 메세지를 생성한다.
7. TCP/IP 연결을 통해 요청한 컴퓨터로 전송
8. 도착한 HTTP 응답 메세지는 HTTP 프로토콜을 활용하여 웹페이지 데이터로 변환되고, 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 된다.

## HTTP

- HyperText Transfer Protocol
- 인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 사용하는 통신 규약
  - 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용
- 거의 모든 형태의 데이터 전송 가능
    - HTML, TEXT
    - IMAGE, 음성, 영상, 파일
    - JSON, XML (API)
- 주로 TCP 기반의 통신 방식
- 특징
  - 클라이언트 서버 구조
  - 무상태 프로토콜
  - 비연결성
  - HTTP 메시지
  - 단순하고 확장 가능

### 1. 기반 프로토콜

- TCP : HTTP/1.1(가장 많이 사용), HTTP/2
- UDP : HTTP/3

### 2. 특징

#### 1) 클라이언트 서버 구조

- Request Response 구조
- 클라이언트는 서버에 요청을 보내고, 응답을 대기
- 서버가 요청에 대한 결과를 만들어서 응답

#### 2) 무상태 프로토콜(stateless)

- 서버가 클라이언트의 상태를 보존하지 않는다.
    - 중간에 서버가 변경되어도 요청과 응답에 지장이 없다.
- 모든 것을 무상태로 설계할 수 없는 경우도 있다.
  - ex) 로그인을 하는 경우 로그인한 상태를 서버에서 유지해야한다.
  - 브라우저 쿠키와 서버 세션 등을 사용해서 상태 유지
  - 상태 유지는 최소한만 사용
- 장점 : 서버 확장성 높음(스케일 아웃)
- 단점 : 클라이언트가 추가 데이터 전송

#### 3) 비연결성
- HTTP는 기본이 연결을 유지하지 않는 모델이다.
- 서버 자원을 효율적으로 사용할 수 있다.
- TCP 기반의 경우 요청할 때마다 연결을 새로 맺어야 한다는 단점이 있지만, HTTP 지속 연결로 최적화를 이루었다.

#### 4) HTTP 메시지
![image](https://user-images.githubusercontent.com/87891581/168089779-753bb923-7180-478f-b3a8-3fd35a864dba.png)
1. start-line
   - request-line(요청 메시지의 경우) : `method SP request-target SP HTTP-version CRLF`
     - HTTP 메서드(ex. `GET`)
     - 요청 대상(ex. `/search?q=hello&hl=ko`)
     - HTTP 버전(ex. `HTTP/1.1`)
   - status-line(응답 메시지의 경우) : `HTTP-version SP status-code SP reason-phrase CRLF`
     - HTTP 버전
     - HTTP 상태 코드 : 요청 성공, 실패를 나타냄 (ex. 200)
     - 이유 문구 : 사람이 이해할 수 있는 짧은 상태코드 설명 글 (ex. OK)
2. HTTP 헤더
   - HTTP 전송에 필요한 모든 부가 정보가 포함된다.
   - ex) 메시지 바디의 크기, 압축, 인증, 요청 클라이언트 정보 등
   - 필요시 임의의 헤더 추가 가능
3. HTTP 메시지 바디
   - 실제 전송할 데이터
   - HTMl 문서, 이미지, 영상, JSON 등 byte로 표현할 수 있는 모든 데이터 전송 가능

#### 5) 단순하고 확장 가능