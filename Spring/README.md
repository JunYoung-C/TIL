# Spring

## 목차

- [EJB와 POJO](#ejb와-pojo)
- [스프링이란](#스프링이란)
- [스프링 부트란](#스프링-부트란)
- [IoC](#IoC)
- [DI](#DI)
- [IoC 컨테이너, DI 컨테이너](#ioc-컨테이너-di-컨테이너)
- [스프링 컨테이너](#스프링-컨테이너)
- [싱글톤 컨테이너](#싱글톤-컨테이너)
- [컴포넌트 스캔](#컴포넌트-스캔)
- [의존 관계 자동 주입](#의존-관계-자동-주입)
- [빈이란](#빈이란)
- [빈의 생명 주기](#빈의-생명-주기)
- [빈 스코프](#빈-스코프)
- [Spring MVC](Spring%20MVC/README.md)
- [Entity, VO, DTO, DAO](#entity-vo-dto-dao)
- [빈 후처리기](#빈-후처리기)
- [AOP](#aop)
- [디자인 패턴](#디자인-패턴)
- [로깅 라이브러리](#로깅-라이브러리)

---

## EJB와 POJO
### EJB
- Enterprise JavaBeans
- 애플리케이션의 업무 로직을 가지고 있는 서버 애플리케이션이다.
  - 주로 웹 시스템에서 JSP가 화면 로직을 처리한다면, EJB는 업무 로직을 처리하는 역할을 한다.
- 로우 레벨의 기술적인 문제(트랜잭션 처리, 상태 관리, 멀티쓰레딩, 리소스풀링, 보안 등)을 처리하여, 쉬운 애플리케이션 개발을 제공하기 위해 등장하였다.
- 하지만 과도한 엔지니어링과 객체 지향적인 특징과 장점을 포기해야 한다는 문제가 있다.
- 마틴 파울러는 EJB와 같은 잘못 설계된 과도한 기술을 피하고, 객체 지향 원리에 다라 만들어진 자바 언어의 충실하게 비즈니스 로직을 구현하는 일명 POJO 방식으로 돌아서야 한다고 지적했다.

### POJO
- Plain Old Java Object
- 자바 언어 사양 외에 어떠한 제한에도 묶이지 않는 자바 오브젝트이다.
  - 프레임워크 인터페이스나 클래스를 구현하거나 확장하지 않는 순수한 클래스를 의미한다.
- 특징
  - Java에서 제공하는 API 외에 종속되지 않음.
  - 특정 규약, 환경에 종속되지 않음
- 장점
  - 코드의 간결함(비즈니스 로직과 특정 환경/low 레벨 종속적인 코드를 분리하므로 단순)
  - 비즈니스 로직과 특정 환경이 분리되므로 단순함.
  - 자동화 테스트에 유리
  - 객체 지향 설계의 자유로운 사용

## 스프링이란

- 스프링은 기업용 온라인 서비스를 지원하기 위한 자바 언어 기반의 프레임워크이다.
- 자바 언어의 가장 큰 특징은 객체 지향 언어라는 것이다.
- 스프링은 [객체 지향 언어가 가진 가장 강력한 특징](../OOP/README.md#좋은-객체-지향-설계의-5가지-원칙solid)을 살려내는 프레임워크.
- [좋은 객체 지향 애플리케이션](../OOP/README.md#객체-지향-프로그래밍)을 개발할 수 있게 도와주는 프레임워크.

## 스프링 부트란

- 스프링을 복잡한 설정 없이 쉽고 빠르게 만들어주는 라이브러리이다.
- 특징
    - 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
    - Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 된다.
    - 손쉬운 빌드 구성을 위한 stater 종속성 제공
    - 스프링과 3rd party(외부) 라이브러리 자동 구성
    - 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
    - 관례에 의한 간결한 설정

## IoC

- Inversion Of Control, 제어의 역전
- 객체의 생성, 생명 주기 관리 등 프로그램의 제어 흐름을 직접 제어하는 것이 아니라, 외부에서 관리하는 것을 말한다.
- 대부분의 프레임워크에서 사용하는 방법으로, 개발자는 프레임워크에 필요한 부분을 개발하고 조립하는 방식의 개발을 하게 된다.

### 프레임 워크 vs 라이브러리

- 프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임 워크가 맞다(JUnit)
- 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 라이브러리다.

## DI

- Dependency Injection, 의존관계 주입 or 의존성 주입
- 애플리케이션 실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존 관계가 연결 되는 것을 의존관계 주입이라고 한다.
- 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.

### 1. 정적인 클래스 의존관계

- 애플리케이션을 실행하지 않아도 import 코드를 보고 분석할 수 있다.
  ![image](https://user-images.githubusercontent.com/87891581/147729405-5b42f0d7-6ffb-4202-ae73-1c450a939542.png)

### 2. 동적인 객체 인스턴스 의존 관계

- 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존관계다.
  ![image](https://user-images.githubusercontent.com/87891581/147729576-56fb37c6-e5d2-4748-8295-f06ad5557f24.png)

## IoC 컨테이너, DI 컨테이너

- 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC 컨테이너 또는 DI 컨테이너라고 한다.
- 의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라 한다.
- 어셈블러, 오브젝트 팩토리 등으로도 불리기도 한다.

## 스프링 컨테이너

- `ApplicationContext` 인터페이스를 구현한 객체를 스프링 컨테이너라고 부른다.
- 스프링 컨테이너는 XML, 자바 코드 등 다양한 형식의 설정 정보로 만들 수 있다. `BeanDefinition`이라는 빈 설정 메타 정보에 의존하기 때문에 가능하다.
    - 스프링 컨테이너는 설정 형식에 맞는 Reader로 설정 정보를 읽고 `BeanDefinition`을 생성한다.
    - 원하는 형식에 맞는 Reader를 만들어서 `BeanDefinion`을 생성할 수 도 있다.
- `ApplicationContext` 인터페이스는 `BeanFactory` 인터페이스를 상속한 서브 인터페이스다.
- 빈의 관리와 조회를 위한 `BeanFactory`에 편리한 부가 기능을 추가한 것을 `ApplicationContext`라고 부른다.
    - 부가 기능에는 메시지소스를 활용한 국제화 기능(국가에 맞게 언어 변환), 환경 변수 기능, 리소스를 편리하게 조회하는 기능 등이 있다.

## 싱글톤 컨테이너

### 1. 스프링 컨테이너와 싱글톤

- 대부분의 스프링 애플리케이션은 웹 애플리케이션이다. 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다.
- 요청할 때 마다 새로운 객체를 생성한다면, 메모리 낭비가 심하다. 이에 대한 해결 방안으로 스프링 컨테이너는 객체를 싱글톤으로 생성하고 관리한다.
    - 싱글톤 패턴이랑 클래스의 인스턴스가 1개만 생성되는 것을 보장하는 디자인 패턴이다.
    - 스프링의 기본 빈 등록 방식은 싱글톤이지만, 싱글톤 방식만 지원하는 것은 아니다.

### 2. 싱글톤 방식의 주의점

- 여러 클라이언트가 하나의 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 무상태로 설계해야 한다.
    - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
    - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
    - 가급적 읽기만 가능해야 한다.
    - 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.

### 3. `@Configuration`과 싱글톤

- 애노테이션 기반의 스프링 컨테이너의 경우, `CGLIB`라는 클래스의 바이트코드를 조작하는 라이브러리를 사용하여 싱글톤을 유지한다.
- 객체 생성을 담당하는 클래스에 `@Configuration`을 적용한다면, `@Bean`이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고, 스프링 빈이 없으면 생성해서 스프링 빈으로 등록하고
  반환하는 코드가 동적으로 만들어진다.
    - `@Bean`만 적용하면 스프링 빈으로 동륵은 되지만, 싱글톤을 보장하지는 않는다.

## 컴포넌트 스캔

- 자바 코드의 `@Bean`이나 XML의 `<bean>` 등을 통해 설정 정보에 스프링 빈을 수동으로 입력할 수 있다.
- 컴포넌트 스캔을 이용하면 설정 정보가 없어도 자동으로 스프링 빈을 등록할 수 있다.
- `@SpringBootApplication`에 `@ComponentScan`이 들어있다.

### 1. 등록 과정

1. `@ComponentScan`이 `@Component`가 붙은 모든 클래스를 스프링 빈으로 등록한다.
    - 이때, 스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자를 사용한다.
    - 필요하다면 빈 이름을 직접 지정할 수 있지만, 권장하지는 않는다.
2. 생성자에 `@Autowired`를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.
    - 이때 기본 조회 전략은 타입이 같은 빈을 찾아서 주입한다.

### 2. 탐색 위치

- 기본적으로 `@ComponentScan`이 붙은 설정 정보 클래스의 패키지가 시작 위치가 된다. 하위 패키지까지 모두 탐색한다.
    - 설정 정보 클래스의 위치를 프로젝트 최상단에 두고, 패키지 위치는 지정하지 않는 방법이 권장된다.
- `basePackages`로 탐색할 패키지의 시작 위치를 지정할 수 있다. 여러 시작 위치를 지정할 수 있다.
- `basePackageClasses`로 지정한 클래스의 패키지를 탐색 시작 위치로 지정할 수 있다.

### 3. 컴포넌트 스캔 기본 대상

컴포넌트 스캔은 `@Component`뿐만 아니라 다른 대상도 스캔한다. 엄밀히 말하면, 다른 어노테이션에 `@Component`가 붙어있다.

- @Component : 기본 스캔 대상
- @Controller : 스프링 MVC 컨트롤러로 인식
- @Service : 특별한 기능은 없으며, 핵심 비즈니스 로직이 존재함을 알리기 위해 사용한다.
- @Repository : 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환해준다.
- @Configuration : 스프링 설정 정보에서 사용한다.

### 4. 필터

컴포넌트 스캔 대상을 추가하거나 제외할 수 있다.

- `includeFilters` : 컨포넌트 스캔 대상을 추가로 지정한다. `@Component`면 충분하기 때문에 거의 사용하지 않는다.
- `excludefilters` : 컴포넌트 스캔에서 제외할 대상을 지정한다. 간혹 사용할 때가 있지만 많지는 않다.

#### FilterType 옵선

- ANNOTATION : 기본값. 애노테이션을 인식해서 동작한다.
- ASSIGNABLE_TYPE : 지정한 타입과 자식 타입을 인식해서 동작한다.
- ASPECT_J : AspectJ 패턴 사용
- REGEX : 정규 표현식
- CUSTOM : TypeFilter 이라는 인터페이스를 구현해서 처리

### 5. 중복 등록과 충돌

#### 1) 자동 빈 간에 빈 이름이 중복되는 경우

- 스프링이 `ConflictingBeanDefinitionException` 예외를 발생시킨다.

#### 2) 수동 빈과 자동 빈 간에 빈 이름이 중복되는 경우

- 수동 빈이 자동 빈을 덮어쓴다.
- 대부분 해당 경우가 의도적으로 발생하지 않기 때문에 최근 스프링 부트에서는 오류가 발생하도록 기본 값을 바꾸었다.

## 의존 관계 자동 주입
- `@Autowired`로 의존 관계 자동 주입을 할 수 있다.
### 다양한 의존 관계 주입 방법
1. 생성자 주입 : 객체를 생성할 때 딱 1번만 호출되므로, 불변하게 설계할 수 있다. 인자를 누락하거나 final 키워드와 같이 사용하여 값이 설정되지 않는 오류를 컴파일 시점에 막을 수 있다. 이런 이유로 인해 권장되는 방법이다.
2. 수정자 주입 : 변경 가능성이 있는 의존관계에 사용된다.
3. 필드 주입 : 간결하지만, 외부에서 변경이 불가능해서 테스트 하기 힘들다는 단점으로 인해 사용하지 않는다.
   - 테스트 코드나 설정을 목적으로 하는 `@Configuration` 같은 곳에서만 예외적으로 사용한다.
4. 메서드 주입 : 한번에 여러 필드를 주입받을 수 있다. 일반적으로 사용하지 않는다.
- 롬복을 사용하면, 편리하게 개발할 수 있다.

### 주입할 스프링 빈이 없어도 동작해야 하는 경우
- `@Autowired(required=false)` : 자동 주입할 대상이 없으면 메서드 자체가 호출이 안된다.
- `org.springframework.lang.@Nullable` : 자동 주입할 대상이 없으면 null이 입력된다.
- `Optional<>` : 자동 주입할 대상이 없으면 Optional.empty가 입력된다.

### 조회 빈이 2개 이상인 경우
- `@Autowired`는 타입으로 조회하기 때문에 선택된 빈이 2개 이상이면 문제가 발생한다.
  - `NoUniqueBeanDefinitionException` 예외가 발생한다.

#### 해결 방법
1. `@Autowired` 필드 명 매칭
   - `@Autowired`는 먼저 타입 매칭을 시도하고, 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭한다.

2. `@Qualifier`끼리 매칭
   - 빈 이름을 변경하지 않고, 추가 구분자를 붙여주는 방법이다.
   - `@Qualifier`가 매칭되는 `@Qualifier`를 찾지 못한다면, 같은 이름을 가진 스프링 빈을 추가로 찾는다.
     - 매칭 되도록 사용하는 것이 좋다.
   - `@Qualifier`를 갖는 애노테이션을 정의하여 편리하게 사용할 수도 있다.
3. `@Primary` 사용
   - `@Autowired`시 여러 빈이 매칭되면 `@Primary`가 우선권을 가진다.

#### @Primary, @Qualifier 활용 방법
- 주로 사용하는 스프링 빈에 `@Primary`를 적용하고, 종종 사용하는 스프링 빈에 `@Qualifier`을 적용하면 코드를 깔끔하게 유지할 수 있다.
- 우선순위는 `@Qualifier`가 더 높다.
  - 스프링은 자동보다는 수동이, 넓은 범위의 선택권 보다는 좁은 범위의 선택권이 우선순위가 높다.

### 조회한 빈이 모두 필요한 경우 - List, Map
- Map이나 List를 사용하면 스프링이 해당 타입에 맞게 조회한 스프링 빈을 담아서 반환한다.
- 해당하는 타입의 스프링 빈이 없다면 빈 컬렉션이나 Map을 주입한다.

### 자동, 수동의 올바른 실무 기준

> 스프링과 스프링 부트가 자동으로 등록하는 수많은 빈들은 예외다. 메뉴얼을 참고해서 스프링 부트가 의도한 대로 편리하게 사용한다.

- 컨트롤러, 서비스, 리포지토리의 경우 자동 기능을 기본으로 사용한다.
  - 숫자가 매우 많다.
  - 문제 발생 시 어떤 곳에서 문제가 발생했는지 명확하게 파악하기 쉽다.
- 비즈니스 로직 중 다형성을 적극 활용하는 경우에는 수동으로 빈을 등록하거나, 자동으로 하면 특정 패키지에 같이 묶어둔다.
- 기술적인 문제나 공통 관심사(AOP)를 처리하는 경우 수동으로 등록한다.
  - 업무 로직에 비해 그 수가 매우 적다.
  - 애플리케이션 전반에 걸쳐 광범위하게 영향을 미치며, 문제 발생 시 파악하기 어렵다.

## 빈이란
- Spring 컨테이너가 관리하는 자바 객체를 빈이라고 부른다.
- `@Bean`이나 xml의 `<Bean>`으로 빈을 수동으로 등록할 수 있고, 컴포넌트 스캔을 이용하면 자동으로 빈을 등록할 수도 있다.

## 빈의 생명 주기
- 스프링 빈 생성 -> 의존 관계 주입 -> 초기화 -> 사용 -> 소멸

### 스프링의 빈 생명주기 콜백 지원 방법
- 스프링은 의존 관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려준다.
- 마찬가지로 스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 준다.
- 스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 지원한다.
  - 인터페이스(InitializingBean, DisposableBean) : 거의 사용하지 않는다.
  - 설정 정보에 초기화 메서드(initMethod), 종료 메서드(destroyMethod) 지정 : 코드를 고칠 수 없는 외부 라이브러리를 초기화하거나 종료해야 할 떄 사용한다.
  - `@PostConstruct`, `@PreDestroy` : 권장하는 방법이다. 외부 라이브러리에는 사용할 수 없다.

#### 1. 인터페이스(InitializingBean, DisposableBean)
- 인터페이스의 메서드를 오버라이딩하여 초기화와 소멸을 할 수 있다.
  - `InitializingBean`은 `afterPropertiesSet()` 메서드로 초기화를 지원한다.
  - `DisposableBean`은 `destory()` 메서드로 소멸을 지원한다.

- 단점
    - 해당 인터페이스는 스프링 전용 인터페이스이다. 따라서 스프링 전용 인터페이스에 의존하게 된다.
    - 초기화, 소멸 메서드의 이름을 변경할 수 없다.
    - 내가 코드를 수정할 수 없는 외부 라이브러리에 적용할 수 없다.

#### 2. 설정 정보에 초기화 메서드, 종료 메서드 지정

- 설정 정보에 `@Bean(initMethod = "메서드명", destroyMethod = "메서드명")`을 기입한다.
- 특징
    - 메서드 이름을 자유롭게 줄 수 있다.
    - 스프링 빈이 스프링 코드에 의존하지 않는다.
    - 코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 적용할 수 있다.
- 종료 메서드 추론
    - `@Bean`의 `@destroyMethod`는 기본값이 (inferred)로 등록되어 있다.
    - 이 추론 기능은 close, shutdown이라는 이름의 메서드를 자동으로 호출한다.
    - 따라서 직접 스프링 빈으로 등록하면 종료 메서드를 따로 적어주지 않아도 잘 동작한다.
    - 추론기능을 사용하기 싫으면 destroyMethod=""처럼 빈 공백을 지정한다.

#### 3. @PostConstruct, @PreDestroy
- 메서드에 애노테이션 하나만 달아주면 된다.
- 스프링에 종속적인 기술이 아닌, 자바 표준이기 때문에 스프링 이외의 컨테이너에서도 동작한다.
- 컴포넌트 스캔과 잘 어울린다.
- 외부 라이브러리에는 적용하지 못한다.

## 빈 스코프
빈이 존재할 수 있는 범위를 의미하며, 스프링은 다음과 같은 다양한 스코프를 지원한다.
- 싱글톤
- 프로토타입
- 웹 관련 스코프
    - request
    - session
    - application
    - websocket

### 싱글톤 스코프
- default 스코프이다.
- Spring IoC 컨테이너 당 한 개의 인스턴스만 생성된다.
- 요청 시 스프링 컨테이너는 관리하고 있던 스프링 빈을 반환한다.

### 프로토타입 스코프
- 스프링 컨테이너에 요청할 때마다 항상 새로운 인스턴스를 생성해서 반환한다.
- 스프링 컨테이너는 생성, 의존관계 주입, 초기화까지만 처리한다.
  - `@PreDestory` 같은 종료 메서드가 호출되지 않는다.
- 빈을 관리할 책임은 빈을 조회한 클라이언트에 있다.
- 매번 사용할 때마다 의존관계 주입이 완료된 새로운 객체가 필요하면 사용한다.
  - 싱글톤 빈으로 대부분의 문제를 해결할 수 있기 때문에 사용하는 일은 매우 드물다.

#### 싱글톤 빈과 함께 사용시 문제점
- 싱글톤 빈이 필드로 프로토타입 빈을 가지고 있는 경우 때 문제가 발생한다.
- 이런 경우에는 싱글톤 빈을 사용할 때마다 프로토타입 빈이 새로 생성되지 않는다.
  - 해당 프로토타입 빈은 이미 과거에 주입이 끝났다.
  - 여러 빈에서 같은 프로토타입 빈을 주입받으면, 주입 받는 시점에 각각 새로운 프로토타입 빈이 생성된다.

#### 사용할 때마다 새로운 프로토타입 빈을 생성하는 방법
**1) 싱글톤 빈이 프로토타입을 사용할 때마다 스프링 컨테이너에 요청하여 사용한다.**
   - `getBean()`으로 항상 새로운 프로토파입 빈을 사용할 수 있다.
   - 이처럼 의존관계를 외부에서 주입(DI) 받는 것이 아니라 직접 필요한 의존관계를 찾는 것을 Dependency LookUp(DL), 의존관계 조회(탐색)이라 한다.
   - 하지만 이 방법은 스프링 컨테이너에 종속적인 코드가 되고, 단위 테스트도 어려워진다.

**2) ObjectProvider**
   - `getObject()`를 호출하면 스프링 컨테이너를 통해 저장한 빈을 컨테이너에서 찾아서 반환한다.(DL)
     - `ObjectFactory`에 편의 기능이 추가되었다.
   - 스프링이 제공하는 기능을 사용하지만, 기능이 단순하므로 단위테스트를 만들기 쉽다.
   - ObjectFactory : 기능이 단순. 별도의 라이브러리 필요없음. 스프링에 의존
   - ObjectProvider : ObjectFactory 상속. 옵션, 스트림 처리 등 편의 기능이 많고, 별도의 라이브러리 필요 없음. 스프링에 의존

**3) JSR-330 Provider**
   - `get()` 메서드 하나로 기능이 매우 단순하다
   - 자바 표준이고, 기능이 단순하므로 단위테스트를 만들기 쉽다.
   - 별도의 라이브러리가 필요하다.
     - `javax.inject:javax.inject:1`를 gradle에 추가하면 사용할 수 있다

**Provider과 ObjectProvider의 사용**
- ObjectProvider는 DL을 위한 편의 기능을 많이 제공해주고 스프링 외의 별도의 의존관계 추가가 필요 없기 때문에 더 편리하다.
- 만약 스프링이 아닌 다른 컨테이너에서도 사용할 수 있어야 한다면 Provider를 사용한다.
    - 그럴 일은 거의 없다.

### 웹 스코프
- 웹 환경에서만 동작한다.
- 스프링이 해당 스코프의 종료시점까지 관리한다. 따라서 종료 메서드가 호출된다.
- 원하는 클래스에 `@Scope(value = "request")`와 같이 사용하여 스코프를 지정할 수 있다.
- 종류 : 범위만 다를 뿐 동작 방식은 다 비슷하다.
    - request : HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프. 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고 관리된다.
    - session : HTTP Session과 동일한 생명주기를 가지는 스코프
    - application : 서블릿 컨텍스트(ServletContext)와 동일한 생명주기를 가지는 스코프
    - websocket : 웹 소켓과 동일한 생명주기를 가지는 스코프

#### 객제 조회 지연 방법
- 웹 스코프 빈은 실제 고객 요청이 와야 생성해서 주입할 수 있다. 따라서 필요한 시점까지 객체 조회를 지연해야한다.

**1) Provider / ObjectProvider**
- `get()`이나 `getObject()`를 호출하는 시점까지 request scope 빈의 생성을 지연할 수 있다.
- 호출하는 시점에는 HTTP 요청이 진행중이므로 request scope 빈의 생성이 정상 처리된다.
- 같은 요청 내에서는 여러번 호출해도 같은 스프링 빈이 반환된다.

**2) 프록시**

![image](https://user-images.githubusercontent.com/87891581/147850805-8a9be5e5-2bd8-48d6-96ee-8ee5917a7f3e.png)
- `@Scope` 설정에 `proxyMode`만 추가해주면 된다.
    - 적용 대상이 클래스면 `TARGET_CLASS`를 선택
    - 적용 대상이 인터페이스면 `INTERFACES`를 선택
- 단지 애노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있다.
    - 이것이 다형성과 DI 컨테이너가 가진 큰 강점이다.
- 웹 스코프가 아니여도 프록시는 사용할 수 있다.

**원리**
- 스프링 컨테이너는 `CGLIB`라는 바이트코드를 조작하는 라이브러리를 사용해서 해당 클래스를 상속받은 가짜 프록시 객체를 생성하고 주입한다.
- 가짜 프록시 객체는 실제 요청이 들어오면 진짜 빈을 요청하는 위임 로직이 들어있다.
- 가짜 프록시 객체는 실제 `request scope`와 관계가 없다. 내부에 단순한 위임 로직만 있고, 싱글톤처럼 동작한다.

**주의점**
- 싱글톤을 사용하는 것 같지만, 다르게 동작하기 때문에 주의해서 사용해야한다.
- 이런 특별한 scope는 꼭 필요한 곳에 최소화해서 사용해야 한다.
  무분별하게 사용하면 유지보수가 어려워진다.

## Entity, VO, DTO, DAO
- Entity : 핵심 비즈니스 도메인이고, JPA에서는 데이터베이스 테이블과 ORM 매핑되어 있는 객체이다. 로직을 가질 수 있다.
- VO(Value Object) : 실제 데이터만을 저장하는 객체이다. 로직을 포함할 수 있으며, 객체의 불변성을 보장한다.
- DTO(Data Transfer Object) : 계층간 데이터 교환을 위해 사용하는 객체이다. 주요 로직 없이, 단순 getter, setter만 존재한다.
- DAO(Data Access Object) : DB에 접근하여 실제 데이터를 조회하거나 조작하는 기능을 가진 객체이다.
  - DAO는 데이터베이스에 더 가깝고, Repository는 도메인 객체에 더 가까운 개념이다.
  - Repository는 DAO를 사용해서 구현할 수 있다.

## 빈 후처리기
- 스프링이 빈 저장소에 등록할 목적으로 생성한 객체를 빈 저장소에 등록하기 직전에 조작할 수 있다.
  - 빈 객체를 프록시로 교체하는 것도 가능하다는 말이다.
- 스프링부트에서는 `AnnotationAwareAspectJAutoProxyCreator`라는 빈 후처리기를 자동으로 등록한다.
  - `@Aspect`를 보고 어드바이저로 변환해서 저장한다.
  - 어드바이저를 기반으로 프록시를 생성한다.

### 자동 프록시 생성기의 작동 과정
![image](https://user-images.githubusercontent.com/87891581/169776161-efbab418-4f24-47a6-b126-05eb9e82ec9c.png)
1. 생성 : 스프링 빈 대상이 되는 객체를 생성한다. (`@Bean`, 컴포넌트 스캔 모두 포함)
2. 전달 : 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.
3. Advisor 빈 조회 : 스프링 컨테이너에서 `Advisor` 빈을 모두 조회한다.
4. `@Aspect` Advisor 조회 : `@Aspect` 어드바이저 빌더 내부에 저장된 `Advisor`를 모두 조회한다.
5. 프록시 적용 대상 체크 : 조회한 `Advisor`에 포함되어 있는 포인트컷을 사용해서 각 객체가 프록시를 적용할 대상인지 확인한다.
6. 프록시 생성 : 프록시 적용 대상이면, 프록시를 생성하고 반환한다. 프록시 적용 대상이 아니라면, 원본 객체를 그대로 반환한다.
7. 빈 등록 : 반환된 객체는 스프링 빈으로 등록된다.

## AOP
### 정의
- Aspect Oriented Programming, 관점 지향 프로그래밍
- 애플리케이션 로직은 핵심 기능과 부가 기능으로 나눌 수 있다.
  - 핵심 기능 : 해당 객체가 제공하는 고유의 기능. 핵심 비즈니스 로직.
  - 부가 기능 : 핵심 기능을 보조하기 위해 제공되는 기능. ex) 로그 추적 로직, 트랜잭션 로직
- 보통 부가 기능은 여러 클래스에 걸쳐서 사용되며, 이런 부가 기능을 횡단 관심사라고 한다.
- AOP는 횡단 관심사를 애스펙트로 모듈화하여 핵심 로직에서 분리하는 프로그래밍 방식을 말한다.
  - 애스펙트 : 부가 기능과, 부가 기능을 어디에 적용할지 정의한 것이다.

### 적용 방식
#### 1. 컴파일 시점에 적용
- `AspectJ`가 사용하는 방법
- 자바 파일이 `.class` 바이트 코드 파일로 컴파일되는 시점에 실제 대상 코드에 애스펙트를 통한 부가 기능 코드가 포함된다.

#### 2. 클래스 로딩 시점에 적용
- `AspectJ`가 사용하는 방법
- `.class` 바이트 코드 파일을 JVM에 저장하기 전에 실제 대상 코드에 애스펙트를 통한 부가 기능 코드가 포함된다. 

#### 3. 런타임 시점에 적용
- `Spring AOP`가 사용하는 방법
- 자바의 메인 메서드가 실행된 후 프록시를 통해 스프링 빈에 부가 기능을 적용한다.
  - 실제 대상 코드는 그대로 유지한다.
  - 프록시는 메서드 오버라이딩 개념으로 동작하기 때문에 메서드 실행 지점에만 AOP를 적용할 수 있다.

### 용어 정리
- Join Point
  - AOP를 적용할 수 있는 모든 지점
    - 메서드 실행, 생성자 호출, 필드 값 접근, static 메서드 접근 등
  - 스프링 AOP는 프록시 방식을 사용하므로, 조인 포인트틑 메서드 실행 지점으로 제한된다.
- Pointcut
  - 조인 포인트 중에서 어드바이스가 적용될 위치를 선별하는 기능
- Target
  - 어드바이스를 받는 객체, 포인트 컷으로 결정
- Advice
  - 부가 기능
  - 특정 조인 포인트에서 Aspect에 의해 취해지는 조치
- Aspect
  - 어드바이스 + 포인트컷을 모듈화 한 것
  - 횡단 관심사를 모듈화 한 것
- Advisor
  - 하나의 어드바이스와 하나의 포인트컷으로 구성
  - 스프링 AOP에서만 사용되는 용어
- Weaving
  - 포인트컷으로 결정한 타켓의 조인 포인트에 어드바이스를 적용하는 것
  - 위빙을 통해 핵심 기능 코드에 영향을 주지 않고 부가 기능을 추가할 수 있다.
- AOP 프록시
  - AOP 기능을 구현하기 위해 만든 프록시 객체
  - 스프링에서 AOP 프록시는 JDK 동적 프록시(인터페이스 전용) 또는 CGLIB 프록시(클래스 전용)이다.

### 스프링 AOP 주의 사항
- 대상 객체 내부에서 메서드 호출이 발생하면, 프록시를 거치지 않고 대상 객체를 직접 호출하는 문제가 발생한다.
  - setter나 `ObjectProvider`를 사용하여 자기 자신을 주입하고 호출하면 해결할 수 있다.
  - 하지만 내부 호출이 발생하지 않도록 구조를 변경하는 것이 가장 권장되는 방법이다.
    - ex) 내부 호출이 외부 호출이 되도록 클래스 분리, 클라이언트에서 둘 다 호출 등
- 인터페이스 기반으로 프록시를 생성하는 JDK 동적 프록시는 구체 클래스로 타입 캐스팅이 불가능하다.
  - 구체 클래스를 기반의 CGLIB 프록시를 사용한다.
    - 기본 생성자 필수, 생성자 2번 호출 문제(`실제 target 객체 생성 시 + 프록시 객체 생성할 때 부모 클래스의 생성자 호출`)는 스프링 4.0부터 해결 되었다.
    - final 키워드 클래스, 메서드 사용 불가 문제는, 잘 사용하지 않으므로 크게 문제가 되지는 않는다.
  - 스프링 부트는 CGLIB를 기본으로 사용한다.

## 디자인 패턴
- 생성 패턴 : 객체 생성에 관련된 패턴
  - 팩토리 패턴 : 객체를 생성 처리를 서브 클래스로 분리해 처리하도록 캡슐화하는 패턴
  - 싱글톤 패턴 : 객체를 1개만 생성하여 항상 참조 가능하도록 고안된 디자인 패턴
- 구조 패턴 : 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
  - 어댑터 패턴 : 호환성이 맞지 않는 두 클래스를 연결하여 사용하기 위한 디자인 패턴
  - 프록시 패턴 : 어떤 객체에 접근 제어를 위해 프록시를 사용하는 디자인 패턴
    - 접근 제어 : 권한에 따른 접근 차단, 캐싱, 지연 로딩 등
  - 데코레이터 패턴 : 어떤 객체에 부가 기능 추가를 위해 프록시를 사용하는 디자인 패턴
    - 부가 기능 : 요청 값이나, 응답 값을 중간에 변형, 시간을 측정해서 추가 로그 남기기 등 
- 행위 패턴 : 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴
  - 전략 패턴 : 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴
  - 템플릿 메서드 패턴 : 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴


## 로깅 라이브러리
- 운영 시스템에서는 시스템 콘솔로 필요한 정보를 출력하지 않고, 로깅 라이브러리를 사용해서 로그를 출력한다.
- 인터페이스 SLF4J, 구현체 Logback 조합을 많이 사용한다.
- 롬복으로 간단하게 `@Slf4j`로 선언할 수 있다.
- LEVEL : `TRACE > DEBUG > INFO > WARN > ERROR`
  - 개발 서버는 debug로 설정한다.
  - 운영 서버는 info로 설정한다.

### 주의점
- `log.debug("data=" + data)` 대신 `log.debug("data={}", data)` 방식을 사용한다.
  - 메서드가 실행이 되지 않더라도, 문자열 더하기 연산은 실행된다.

### 장점
- 쓰레드 정보, 클래스 이름 같은 부가 정보를 함께 볼 수 있고, 출력 모양을 조정할 수 있다.
- 로그 레벨에 따라 개발 서버에서는 모든 로그를 출력하고, 운영 서버에서는 출력하지 않는 등 상황에 맞게 조절 가능하다.
- 콘솔 뿐만 아니라, 파일이나 네트워크 등 로그를 별도의 위치에 남길 수 있다.
  - 파일로 남길 때는 일별, 특정 용량에 따라 로그를 분할하는 것도 가능하다.
- `System.out`보다 성능이 좋다.(내부 버퍼링, 멀티 쓰레드 등)
