# Spring

> 참고자료 : 김영한 - spring 기본

- 자바 언어 기반의 프레임워크
- 핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 최근에는 스프링 부트를 통해서 스프링 프레임워크 기술들을 편리하게 사용

## 1. 스프링의 핵심 컨셉

- 객체 지향 언어가 가진 강력한 특성을 살려내는 프레임워크
- **좋은 객체 지향** 애플리케이션을 개발할 수 있게 도와주는 프레임 워크

## 2. 스프링과 객체 지향

- 스프링에서의 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.
- 스프링을 사용하면 구현을 편리하게 변경할 수 있다.

### 1) 역할과 구현의 분리

- 클라이언트가 대상의 내부 구조를 모르더라도, 역할(인터페이스)을 알면 해당 기능을 사용할 수 있다.
- 자바 언어의 다형성을 활용
  - 역할 = 인터페이스
  - 구현 = 인터페이스를 구현한 클래스, 구현 객체

#### (1) 장점

- 유연하고, 변경이 용이
- 확장 가능한 설계
- 클라이언트에 영향을 주지 않는 변경 가능

#### (2) 단점

- 역할(인터페이스)이 변하면 클라이언트, 서버 모두에 큰 변경이 발생한다.
  - 인터페이스를 안정적으로 잘 설계하는 것이 중요하다.
- 인터페이스를 도입하면 추상화라는 비용이 발생한다.
  - 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법이다.

### 2. 스프링과 SOLID

- 객체 지향의 핵심은 다형성이다.
- 하지만 다형성만으로는 구현 객체를 변경할 때, 클라이언트 코드도 함께 변경되기 때문에 OCP, DIP를 지킬 수 없다.
- 스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원한다.
  - DI(Dependency Injection) : 의존관계, 의존성 주입
  - DI 컨테이너 제공 : 구현 객체를 생성하고 연결하는 책임을 가진다.
- 스프링을 사용하면 클라이언트 코드의 변경 없이 기능 확장이 가능

---

# IoC

- Inversion Of Control, 제어의 역전
- 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고 실행했다.
  - 자연스러운 흐름이지만, 로직 실행 이외의 객체의 생성과 연결이라는 책임을 추가로 가지게 된다.
- DI 컨테이너가 객체의 생성과 연결 책임을 담당하면서, 구현 객체는 자신의 로직 실행 역할만 담당하면 된다.
- 이렇듯 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전(IoC)이라 한다.

## 프레임 워크 vs 라이브러리

- 프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임 워크가 맞다(JUnit)
- 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 라이브러리다.

---

# DI

- Dependency Injection, 의존관계 주입 or 의존성 주입
- 애플리케이션 실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존 관계가 연결 되는 것을 의존관계 주입이라고 한다.
- 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.

## 1. 정적인 클래스 의존관계

- 애플리케이션을 실행하지 않아도 import 코드를 보고 분석할 수 있다.
  ![image](https://user-images.githubusercontent.com/87891581/147729405-5b42f0d7-6ffb-4202-ae73-1c450a939542.png)

## 2. 동적인 객체 인스턴스 의존 관계

- 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존관계다.
  ![image](https://user-images.githubusercontent.com/87891581/147729576-56fb37c6-e5d2-4748-8295-f06ad5557f24.png)

---

# IoC 컨테이너, DI 컨테이너

- 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC 컨테이너 또는 DI 컨테이너라고 한다.
- 의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라 한다.
- 어셈블러, 오브젝트 팩토리 등으로도 불리기도 한다.

---

# 스프링 컨테이너와 스프링 빈

## 1. 스프링 컨테이너

- `ApplicationContext`를 스프링 컨테이너라 한다.
- `ApplicationContext`는 인터페이스다.
- 스프링 컨테이너는 XML을 기반으로 만들 수 있고, 애노테이션 기반의 자바 설정 클래스로 만들 수 있다.

## 2. 스프링 컨테이너의 생성 과정

1. **스프링 컨테이너 생성**
2. **스프링 빈 등록**
3. **스프링 빈 의존관계 설정 - 준비**
4. **스프링 빈 의존관계 설정 - 완료**

## 3. 컨테이너에 등록된 빈 조회

- ac.getBeanDefinitionNames() : 스프링에 등록된 모든 빈 이름을 조회한다.
- ac.getBean() : 빈 이름으로 빈 객체(인스턴스)를 조회한다.
  - 구체 타입으로 조회하면 변경 시 유연성이 떨어진다.
- ac.getBeansOfType() : 해당 타입의 모든 빈을 조회할 수 있다.
- 부모 타입으로 조회하면, 자식 타입도 함께 조회한다.
- Object 타입으로 조회하면, 모든 스프링 빈을 조회한다.

## 4. BeanFactory와 ApplicationContext

- beanFactory나 ApplicationContext를 스프링 컨테이너라고 한다.
- BeanFactory를 직접 사용하는 경우는 거의 없으므로 일반적으로 ApplicationContext를 스프링 컨테이너라고 한다.

### 1) BeanFactory

- 스프링 컨테이너의 최상위 인터페이스다.
- 스프링 빈을 관리하고 조회하는 역할을 담당한다.
- getBean()을 제공한다.

### 2) ApplicationContext

- BeanFactory 기능과 더불어 부가기능을 제공한다.

![image](https://user-images.githubusercontent.com/87891581/147756911-6ff8ccec-7d6b-4383-81d2-7dfa5a76fac6.png)

- 메시지 소스를 활용한 국제화 기능 : 한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력
- 환경변수 : 로컬, 개발, 운영 등을 구분해서 처리
- 애플리케이션 이벤트 : 이벤트를 발행하고 구독하는 모델을 편리하게 지원
- 편리한 리소스 조회 : 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회

## 5. 다양한 설정 지원 - 자바 코드, XML

![image](https://user-images.githubusercontent.com/87891581/147757714-7c3b64f7-3959-4d74-8406-70b8fb615b8b.png)

- 스프링 컨테이너는 다양한 형식의 설정 정보를 받아들일 수 있게 유연하게 설계되어 있다.
- 각각의 Reader가 BeanDefinition을 생성하고, 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다.

### BeanDefinition

> BeanDefinition을 직접 생성해서 스프링 컨테이너에 등록할 수도 있다. 하지만 실무에서 직접 정의하거나 사용할 일은 거의 없다.

![image](https://user-images.githubusercontent.com/87891581/147758154-f8eb773a-f956-4099-b7fe-2bb50d204213.png)

- BeanClassName : 생성할 빈의 클래스명(자바 설정처럼 팩토리 역할의 빈을 사용하면 없다)
- factoryBeanName : 팩토리 역할의 빈을 사용할 경우 이름. 예) appConfig
- factoryMethodName : 빈을 생성할 팩토리 메서드 지정. 예) memberService
- Scope : 싱글톤(기본값)
- laxyInit : 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아니라, 실제 빈을 사용할 때까지 최대한 생성을 지연처리 하는지 여부
- InitMethodName : 빈을 생성하고, 의존관계를 적용한 뒤에 호출되는 초기화 메서드 명
- DestroyMethodName : 빈의 생명주기가 끝나서 제거하기 직전에 호출되는 메서드 명
- Constructor arguments, Properties : 의존관계 주입에서 사용한다.(자바 설정처럼 팩토리 역할의 빈을 사용하면 없다)

---

# 싱글톤 컨테이너

## 1. 웹 애플리케이션과 싱글톤

- 스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생했다.
- 대부분의 스프링 애플리케이션은 웹 애플리케이션이다. 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다.
  - 물론 다른 애플리케이션 개발이 가능하다.
- 요청할 때 마다 새로운 객체를 생성한다면, 메모리 낭비가 심하다.
  - 싱글톤 패턴을 활용해야 한다.

## 2. 싱글톤 패턴

- 클래스의 인스턴스가 1개만 생성되는 것을 보장하는 디자인 패턴이다.

### 1) 장점

- 고객의 요청이 올 때마다 이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다.

### 2) 단점

- 싱글톤 패턴을 구현하는 코드양이 상당하다.
- 의존관계상 클라이언트가 구체 클래스에 의존한다.
  - DIP, OCP 위반
- 테스트하기 어렵다.
- 내부 속성을 변경하거나 초기화 하기 어렵다.
- private 생성자로 자식 클래스를 만들기 어렵다.
- 결론적으로 유연성이 떨어진다.
- 안티패턴이라고 불리기도 한다.

## 3. 싱글톤 컨테이너

- 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤으로 관리한다.
  - 싱글톤 패턴을 위한 코드를 작성하지 않아도 된다.
  - DIP, OCP, 테스트, private 생성자로부터 자유롭게 싱글톤을 사용할 수 있다.
- 스프링 컨테이너는 싱글톤 컨테이너의 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다.
  - 스프링의 기본 등록 방식은 싱글톤이지만, 싱글톤 방식만 지원하는 것은 아니다.

## 4. 싱글톤 방식의 주의점

- 여러 클라이언트가 하나의 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지하게 설계하면 안된다.
- 즉, 무상태로 설계해야 한다.
  - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
  - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
  - 가급적 읽기만 가능해야 한다.
  - 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.

## 5. @Configuration과 싱글톤

![image](https://user-images.githubusercontent.com/87891581/147808366-58fd3d1b-3d71-44bc-bd82-9946224f783b.png)

- AppConfig와 같은 DI 컨테이너(빈 팩토리)에 `@Configuration`을 달아줄 경우, 스프링이 CGLIB라는 바이트 코드조작 라이브버리를 상용해서 AppConfig 클래스를 상속받은 임의의 다른 클래스를 만들어 스프링 빈으로 등록한다.
- @bean이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고, 스프링 빈이 없으면 생성해서 스프링 빈으로 등록하고 반환하는 코드가 동적으로 만들어진다.
- `AppConfig@CGLIB`는 `AppConfig`의 자식 타입이므로, AppConfig 타입으로 조회 가능하다.
  `@Configuration`을 적용하지 않으면, 스프링 빈으로 등록은 되지만 싱글톤으로 보장되지 않는다.

---

# 컴포넌트 스캔

- 스프링 빈을 등록하기 위해 자바 코드의 `@Bean`이나 XML의 `<bean>` 등을 통해 설정 정보에 수동으로 입력할 수 있다.
- 컴포넌트 스캔을 이용하면 설정 정보가 없어도 자동으로 스프링 빈을 등록할 수 있다.

## 1. 등록 과정

1. `@CompnentScan`이 `@Component`가 붙은 모든 클래스를 스프링 빈으로 등록한다.
   - 이때, 스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자를 사용한다.
   - 필요하다면 빈 이름을 직접 지정할 수 있지만, 권장하지는 않는다.
2. 생성자에 `@Autowired`를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.
   - 이때 기본 조회 전략은 타입이 같은 빈을 찾아서 주입한다.

## 2. 탐색 위치

- 기본적으로 `@CompnentScan`이 붙은 설정 정보 클래스의 패키지가 시작 위치가 된다. 하위 패키지까지 모두 탐색한다.
  - 설정 정보 클래스의 위치를 프로젝트 최상단에 두고, 패키지 위치는 지정하지 않는 방법이 권장된다.
  - `@SpringBootApplication`에 `@ComponentScan`이 들어있다.
- `basePackages`로 탐색할 패키지의 시작 위치를 지정할 수 있다. 여러 시작 위치를 지정할 수 있다.
- `basePackageClasses`로 지정한 클래스의 패키지를 탐색 시작 위치로 지정할 수 있다.

## 3. 컴포넌트 스캔 기본 대상

컴포넌트 스캔은 `@Component`뿐만 아니라 다른 대상도 스캔한다.

- @Component : 기본 스캔 대상
- @Controller : 스프링 MVC 컨트롤러로 인식
- @Service : 특별한 기능은 없으며, 핵심 비즈니스 로직이 존재함을 알리기 위해 사용한다.
- @Repository : 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프리 예외로 변환해준다.
- @Configuration : 스프링 설정 정보에서 사용한다.

## 4. 필터

> `@Component`면 충분하기 때문에, `includeFilter`를 거의 사용하지 않는다. `excludeFilters`는 간혹 사용할 때가 있지만 많지는 않다.

- `includeFilters` : 컨포넌트 스캔 대상을 추가로 지정한다.
- `excludefilters` : 컴포넌트 스캔에서 제외할 대상을 지정한다.

### FilterType 옵선

- ANNOTATION : 기본값. 애노테이션을 인식해서 동작한다.
- ASSIGNABLE_TYPE : 지정한 타입과 자식 타입을 인식해서 동작한다.
- ASPECT_J : AspectJ 패턴 사용
- REGEX : 정규 표현식
- CUSTOM : TypeFilter 이라는 인터페이스를 구현해서 처리

## 5. 중복 등록과 충돌

### 1) 자동 빈 간에 빈 이름이 중복되는 경우

- 스프링이 `ConflictingBeanDefinitionException` 예외를 발생시킨다.

### 2) 수동 빈과 자동 빈간에 빈 이름이 중복되는 경우

- 수동 빈이 자동 빈을 덮어쓴다.
- 대부분 해당 경우가 의도적으로 발생하지 않기 때문에 최근 스프링 부트에서는 오류가 발생하도록 기본 값을 바꾸었다.

---

# 의존관계 자동 주입

## 1. 의존관계 주입 방법

- 여러 방법이 있지만, 기본으로 생성자 주입을 사용하고 필수값이 아닌 경우에 수정자 주입 방식을 옵션으로 부여하자.

### 1) 생성자 주입

> 권장하는 방법

- 생성자 호출시점에 딱 한번만 호출되는 것이 보장된다.
- 불편, 필수 의존 관계에 사용

#### 권장하는 이유

(1) 불변

- 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료 시점까지 의존관계를 변경할 일이 없다. 오히려 대부분의 의존관계는 애플리케이션 종료 전까지 변하면 안된다.
- 수정자 주입을 사용하면 setter 메서드를 public으로 열어두어야 한다. 누군가 실수로 변경할 수 있기 때문에 변경하면 안되는 메서드를 열어두는 것은 좋은 설계 방법이 아니다.
- 생성자 주입은 객체 생성할 때 1번만 호출되기 때문에 이후에 호출되는 일이 없다. 따라서 불변하게 설계할 수 있다.
  (2) 누락
- 생성자 주입을 사용하면 주입 데이터를 누락 했을 때 컴파일 오류가 발생한다.
  - 어떤 값이 누락됐는지 바로 알 수 있다.
- setter 주입을 사용하면 실행 이후에 오류를 확인 할 수 있다.
  (3) final 키워드
- 생성자 주입을 사용하면 필드에 final 필드를 사용할 수 있다.
- 혹여나 생성자에서 값을 설정하지 않더라도 컴파일 오류로 바로 알아차릴 수 있다.

```java
private final MemberRepository memberRepository;
private final DiscountPolicy discountPolicy;

@Autowired
public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy
discountPolicy) {
   this.memberRepository = memberRepository;
   this.discountPolicy = discountPolicy;
}
```

- 스프링 빈의 생성자가 1개만 존재한다면 `@Autowired`를 생략해도 자동 주입된다.

### 2) 수정자 주입(setter 주입)

- 필드의 값을 변경하는 setter 수정자 메서드를 통해 의존관계를 주입할 수 있다.
- 선택, 변경 가능성이 있는 의존관계에 사용

```java
private MemberRepository memberRepository;

@Autowired
public void setMemberRepository(MemberRepository memberRepository) {
  this.memberRepository = memberRepository;
}
```

### 3) 필드 주입

> 사용하지 말자!

- 필드에 바로 주입하는 방법이다.
- 코드가 간결하지만, 외부에서 변경이 불가능하기 때문에 테스트하기 힘들다.
- DI 프레임워크가 없으면 아무것도 할 수 없다.
- 예외적으로 사용하는 경우
  - 애플리케이션의 실제 코드와 관계없는 테스트 코드
  - 스프링 설정을 목적으로 하는 @Configuration 같은 곳에서만 특별한 용도로 사용

```java
@Autowired
private MemberRepository memberRepository;
```

### 4) 일반 메서드 주입

- 일반 메서드를 통해 주입받을 수 있다.
- 한번에 여러 필드를 주입받을 수 있다.
- 일반적으로 잘 사용하지 않는다.

```java
private MemberRepository memberRepository;
private DiscountPolicy discountPolicy;

@Autowired
public void init(MemberRepository memberRepository, DiscountPolicy
discountPolicy) {
  this.memberRepository = memberRepository;
  this.discountPolicy = discountPolicy;
}
```

## 2. 옵션 처리

- 주입할 스프링 빈이 없어도 동작하게 할 수 있다.

1. `@Autowired(required=false)` : 자동 주입할 대상이 없으면 메서드 자체가 호출이 안된다.
2. `org.springframework.lang.@Nullable` : 자동 주입할 대상이 없으면 null이 입력된다.
3. `Optional<>` : 자동 주입할 대상이 없으면 Optional.empty가 입력된다.

## 3. 롬복과 최신 트렌드

- 롬복 라이브러리가 제공하는 `@RequiredArgsConstructor` 기능을 사용하면 final이 붙은 필드를 모아서 생성자를 자동으로 만들어준다.
- 최근에는 생성자를 1개만 두고, `@Autowired`를 생략하는 방법을 주로 사용한다. 여기에 `@RequiredArgsConstructor`를 함께 사용하면 매우 간결한 코드를 작성할 수 있다.
- 이외에 `@getter`, `@setter` 등의 기능도 많이 사용된다.

## 4. 조회 빈이 2개 이상인 경우

- `@Autowired`는 타입으로 조회하기 때문에 선택된 빈이 2개 이상이면 문제가 발생한다.
  - `NoUniqueBeanDefinitionException` 예외가 발생한다.
- 스프링 빈을 수동 등록해서 문제를 해결해도 되지만, 의존 관계 자동 주입에서 해결하는 여러 방법이 있다.

## 1) 해결 방법

#### (1) @Autowired 필드 명 매칭

- `@Autowired`는 먼저 타입 매칭을 시도하고, 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭한다.

#### (2) @Qualifier 매칭

- 추가 구분자를 붙여주는 방법이다.
- 빈 이름을 변경하는 것이 아니다.

```java
@Component
@Qualifier("mainDiscountPolicy")
public class RateDiscountPolicy implements DiscountPolicy {}
```

```java
@Autowired
public OrderServiceImpl(MemberRepository memberRepository,
 @Qualifier("mainDiscountPolicy") DiscountPolicy
discountPolicy) {
  this.memberRepository = memberRepository;
  this.discountPolicy = discountPolicy;
}
```

- `@Qualifier`가 매칭되는 `@Qualifier`를 찾지 못한다면, 같은 이름을 가진 스프링 빈을 추가로 찾는다.
  - 매칭 되도록 사용하는 것이 좋다.

#### (3) @Primary 사용

- `@Autowired`시 여러 빈이 매칭되면 `@Primary`가 우선권을 가진다.

### 2) @Primary, @Qualifier 활용

- 자주 사용하는 메인 데이터베이스의 커넥션을 획득하는 스프링 빈은 `@Primary`를 적용해서 조회하는 곳에서 별다른 지정 없이 편리하게 조회하고, 서브 데이터데이브 커넥션 빈을 획득할 때는 `@Qualifier`를 지정해서 명시적으로 획득하는 방식을 사용하면 코드를 깔끔하게 유지할 수 있다.
- 우선순위는 `@Qualifier`가 더 높다.
  - 스프링은 자동보다는 수동이, 넓은 범위의 선택권 보다는 좁은 범위의 선택권이 우선순위가 높다.

#### 애노테이션 활용

- `@Qualifier("mainDiscountPolicy")`와 같이 문자로 적어져 있으면, 컴파일시 타입 체크가 안된다.
- 애노테이션을 만들어 문제를 해결할 수 있다.

```java
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER,
ElementType.TYPE, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Qualifier("mainDiscountPolicy")
public @interface MainDiscountPolicy {
}
```

```java
@Component
@MainDiscountPolicy
public class RateDiscountPolicy implements DiscountPolicy {}
```

## 5. 조회한 빈이 모두 필요할 때 - List, Map

- 의도적으로 해당 타입의 스프링 빈이 필요한 경우가 있다.
- Map이나 List를 사용하면 스프링이 해당 타입에 맞게 조회한 스프링 빈을 담아서 반환한다.
- 해당하는 타입의 스프링 빈이 없다면 빈 컬렉션이나 Map을 주입한다.

```java
private final Map<String, DiscountPolicy> policyMap;
private final List<DiscountPolicy> policies;

@Autowired
public DiscountService(Map<String, DiscountPolicy> policyMap,
List<DiscountPolicy> policies) {
  this.policyMap = policyMap;
  this.policies = policies;
 }
```

## 6. 자동, 수동의 올바른 실무 기준

> 스프링과 스프링 부트가 자동으로 등록하는 수많은 빈들은 예외다. 메뉴얼을 참고해서 스프링 부트가 의도한 대로 편리하게 사용한다.

### 1) 편리한 자동 기능을 기본으로 사용한다.

- 설정 정보를 기반으로 애플리케이션 구성 부분과 실제 동작 부분을 명확하게 나누는 것이 이상적이다.
- 하지만 수동 등록은 상당히 번거롭고, 관리할 빈이 많으면 설정 정보를 관리하는 것 자체가 부담이 된다.
- 자동 빈 등록을 사용해도 OCP, DIP를 지킬 수 있다.
  - 물론 수동 빈 만큼은 아니다.

### 2) 기술 지원 객체는 수동으로 등록한다.

- 애플리케이션은 크게 업무로직과 기술 지원 로직으로 나눌 수 있다.
  - 업무 로직 빈 : 웹을 지원하는 컨트롤러, 핵심 비즈니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는 리포지토리 등이 모두 업무 로직이다. 보통 비즈니스 요구사항을 개발할 때 추가되거나 변경된다.
  - 기술 지원 빈 : 기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용된다. 데이터베이스 연결이나, 공통 로그 처리처럼 업무 로직을 지원하기 위한 하부 기술이나 공통 기술들이다.
- 업무 로직은 다음의 특징으로 인해 자동 기능을 적극 사용하는 것이 좋다.
  - 숫자가 매우 많다.
  - 컨트롤러, 서비스, 리포지토리처럼 어느정도 유사한 패턴이 있다.
  - 보통 문제가 발생해도 어떤 곳에서 문제가 발생했는지 명확하게 파악하기 쉽다.
- 기술지원 로직은 다음의 특징으로 인해 가급적 수동 빈 등록을 사용해서 명확이 들어내는 것이 좋다.
  - 업무 로직에 비해 그 수가 매우 적다.
  - 보통 애플리케이션 전반에 걸쳐서 광범위하게 영향을 미친다.
  - 업무 로직을 문제 발생시 어디가 문제인지 명확하게 잘 들어나지만, 기술 지원 로직은 적용이 잘 되고 있는지 조차 파악하기 어려운 경우가 많다.

### 3) 다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민한다.

- `DiscountService`가 의존관계 자동 주입으로 `Map<String, DiscountPolicy>`에 주입을 받는 경우, 여기에 어떤 빈들이 주입 될지, 각 빈들의 이름은 무엇일지 코드만 보고 쉽게 파악하기 어렵다.
- 이런 경우 수동으로 빈을 등록하거나, 자동으로 하면 특정 패키지에 같이 묶어두는 것이 좋다.

---

# 빈 생명주기 콜백

- 스프링 빈은 객체를 생성하고, 의존관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가 완료된다. 따라서 초기화 작업은 의존관계 주입이 모두 완료된 후에 호출해야 한다.
- 스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공한다. 또한, 스프링 컨에티어가 종료되기 직전에 소멸 콜백을 준다.

## 1. 객체의 생성과 초기화

- 생성자는 필수 정보(파라미터)를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다.
- 초기화는 이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는 등 무거운 동작을 수행한다.
- 따라서 생성자 안에서 무거운 초기화 작업을 함께 하는 것 보다는 객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 유지보수 관점에서 더 좋다.
  - 물론, 초기화 작업이 내부 값들만 약간 변경하는 정도로 단순한 경우에는 생성자에서 한번에 다 처리하는게 더 나을 수 있다.

## 2. 스프링 빈의 이벤트 라이프 사이클

> 싱글톤인 경우에 해당

1. 스프링 컨테이너 생성
2. 스프링 빈 생성
3. 의존관계 주입
4. 초기화 콜백 : 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출
5. 사용
6. 소멸전 콜백 : 빈이 소멸되기 적전에 호출
7. 스프링 종료

## 3. 스프링의 빈 생명주기 콜백 지원 방법

- 기본적으로 `@PostConstruct`, `@PreDestroy`를 사용한다.
- 코드를 고칠 수 없는 외부 라이브러리를 초기화, 종료해야 한다면 `@Bean`의 `initMethod`, `destroyMethod`를 사용한다.

### 1) 인터페이스(InitializingBean, DisposableBean)

> 현재는 거의 사용하지 않는다.

- `InitializingBean`은 `afterPropertiesSet()` 메서드로 초기화를 지원한다.
- `DisposableBean`은 `destory()` 메서드로 소멸을 지원한다.

```java
public class NetworkClient implements InitializingBean, DisposableBean {
  @Override
  public void afterPropertiesSet() throws Exception {
  }

  @Override
  public void destroy() throws Exception {
  }
}
```

- 단점
  - 해당 인터페이스는 스프링 전용 인터페이스이다. 따라서 스프링 전용 인터페이스에 의존하게 된다.
  - 초기화, 소멸 메서드의 이름을 변경할 수 없다.
  - 내가 코드를 수정할 수 없는 외부 라이브러리에 적용할 수 없다.

### 2) 설정 정보에 초기화 메서드, 종료 메서드 지정

- 설정 정보에 `@Bean(initMethod = "메서드명", destroyMethod = "메서드명")`을 기입한다.
- 특징
  - 메서드 이름을 자유롭게 줄 수 있다.
  - 스프링 빈이 스프링 코드에 의존하지 않는다.
  - 코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 적용할 수 있다.
- 종료 메서드 추론
  - @Bean의 @destroyMethod는 기본값이 (inferred)로 등록되어 있다.
  - 이 추론 기능은 close, shutdown이라는 이름의 메서드를 자동으로 호출한다.
  - 따라서 직접 스프링 빈으로 등록하면 종료 메서드를 따로 적어주지 않아도 잘 동작한다.
  - 추론기능을 사용하기 싫으면 destroyMethod=""처럼 빈 공백을 지정한다.

### 3) @PostConstruct, @PreDestroy

- 해당 메서드에 애노테이션을 달아주면 된다.
- 특징
  - 최신 스프링에서 가장 권장하는 방법이다.
  - 애노테이션 하나만 붙이면 되므로 매우 편리하다.
  - 스프링에 종속적인 기술이 아닌, 자바 표준이기 때문에 스프링 이외의 컨테이너에서도 동작한다.
  - 컴포넌트 스캔과 잘 어울린다.
  - 외부 라이브러리에는 적용하지 못한다.

---

# 빈 스코프

스프링은 다음과 같은 다양한 스코프를 지원한다.

- 싱글톤 : 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.
- 프로토타입 : 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프이다.
- 웹 관련 스코프
  - request : 웹 요청이 들어오고 나갈때까지 유지되는 스코프이다.
  - session : 웹 세션이 생성되고 종료될 때까지 유지되는 스코프이다.
  - application : 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프이다.

## 1. 프로토타입 스코프

- 스프링 컨테이너에 요청할 때마다 새로 생성된다.
- 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다.
- 관리할 책임은 빈을 받은 클라이언트에 있다.
- `@PreDestory` 같은 종료 메서드가 호출되지 않는다.

### 1) 싱글톤 빈 요청

1. 싱글톤 스코프의 빈을 스프링 컨테이너에 요청한다.
2. 스프링 컨테이너는 본인이 관리하는 스프링 빈을 반환한다.
3. 이후에 스프링 컨테이너에 같은 요청이 와도 객체 인스턴스의 스프링 빈을 반환한다.

### 2) 프로토타입 빈 요청

1. 프로토탕비 스코프의 빈을 스프링 컨테이너에 요청한다.
2. 스프링 컨테이너는 이 시점에 프로토타입 빈을 생성하고, 필요한 의존관계를 주입한다.
3. 스프링 컨테이너는 생성한 프로토타입 빈을 클라이언트에 반환한다.
4. 이후에 스프링 컨테이너에 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성해서 반환한다.

## 2. 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점

- 싱글톤 빈이 의존관계 주입을 통해서 프로토타입 빈을 주입받아서 사용할 때 문제가 발생한다.
- 이런 경우에는 싱글톤 빈을 사용할 때마다 프로토타입 빈이 새로 생성되지 않는다.
  - 해당 프로토타입 빈은 이미 과거에 주입이 끝났다.
  - 여러 빈에서 같은 프로토타입 빈을 주입받으면, 주입 받는 시점에 각각 새로운 프로토타입 빈이 생성된다.

## 3. 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제 해결

### 1) 스프링 컨테이너에 요청

- 싱글톤 빈이 프로토타입을 사용할 때마다 스프링 컨테이너에 새로 요청한다.

```java
@Autowired
private ApplicationContext ac;

public int logic() {
  PrototypeBean prototypeBean = ac.getBean(PrototypeBean.class);
}
```

- 이처럼 의존관계를 외부에서 주입(DI) 받는 것이 아니라 직접 필요한 의존관계를 찾는 것을 Dependency LookUp(DL), 의존관계 조회(탐색)이라 한다.
- 하지만 이 방법은 스프링 컨테이너에 종속적인 코드가 되고, 단위 테스트도 어려워진다.

### 2) ObjectProvider

- `ObjectProvider`는 필요한 DL 정도의 기능만 제공한다.
- `ObjectFactory`에 편의 기능이 추가되었다.

```java
@Autowired
private ObjectProvider<PrototypeBean> prototypeBeanProvider;

public int logic() {
  PrototypeBean prototypeBean = prototypeBeanProvider.getObject();
}
```

- getObject()를 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다.(DL)
- 스프링이 제공하는 기능을 사용하지만, 기능이 단순하므로 단위테스트를 만들어가 mock 코드를 만들기는 훨씬 쉬워진다.
- 특징
  - ObjectFactory : 기능이 단순. 별도의 라이브버리 필요없음. 스프링에 의존
  - ObjectProvider : ObjectFactory 상속. 옵션, 스트림 처리 등 편의 기능이 많고, 별도의 라이브러리 필요 없음. 스프링에 의존

### 3) JSR-330 Provider

- `javax.inject:javax.inject:1`를 gradle에 추가하면 사용할 수 있다

```java
@Autowired
private Provider<PrototypeBean> provider;

public int logic() {
  PrototypeBean prototypeBean = provider.get();
}
```

- 자바 표준이고, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기는 훨씬 쉬워진다.
- 특징
  - get() 메서드 하나로 기능이 매우 단순하다
  - 별도의 라이브러리가 필요하다.
  - 자바 표준이므로 스프링이 아닌 다른 컨테이너에서도 사용 가능하다.

## 4. 실무에서의 프로토타입 빈

- 매번 사용할 때마다 의존관계 주입이 완료된 새로운 객체가 필요하면 사용한다.
- 싱글톤 빈으로 대부분의 문제를 해결할 수 있기 때문에 프로토타입 빈을 직접적으로 사용하는 일은 매우 드물다.

### Provider과 ObjectProvider의 사용

- ObjectProvider는 DL을 위한 편의 기능을 많이 제공해주고 스프링 외의 별도의 의존관계 추가가 필요 없기 때문에 더 편리하다.
- 만약 스프링이 아닌 다른 컨테이너에서도 사용할 수 있어야 한다면 Provider를 사용한다.
  - 그럴 일은 거의 없다.

## 5. 웹 스코프

- `Scope(value = "request")`와 같이 사용하여 스코프를 지정한다.
- 특징
  - 웹 환경에서만 동작한다.
  - 스프링이 해당 스코프의 종료시점까지 관리한다. 따라서 종료 메서드가 호출된다.
- 종류 : 범위만 다를 뿐 동작 방식은 다 비슷하다.
  - request : HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고 관리된다.
  - session : HTTP Session과 동일한 생명주기를 가지는 스코프
  - application : 서블릿 컨텍스트(ServletContext)와 동일한 생명주기를 가지는 스코프
  - websocket : 웹 소켓과 동일한 생명주기를 가지는 스코프
- request 스코프 빈은 실제 고객 요청이 와야 생성해서 주입할 수 있다. 따라서 필요한 시점까지 객체 조회를 지연해야한다.

## 6. 웹 스코프 - 객제 조회 지연 방법

### 1) Provider / ObjectProvider

- get()이나 getObject()를 호출하는 시점까지 request scope 빈의 생성을 지연할 수 있다.
- 호출하는 시점에는 HTTP 요청이 진행중이므로 request scope 빈의 생성이 정상 처리된다.

### 2) 프록시

![image](https://user-images.githubusercontent.com/87891581/147850805-8a9be5e5-2bd8-48d6-96ee-8ee5917a7f3e.png)

```java
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class MyLogger {
}
```

- 다른 코드의 수정 없이 proxyMode만 추가해주면 된다.
  - 적용 대상이 클래스면 `TARGET_CLASS`를 선택
  - 적용 대상이 인터페이스면 `INTERFACES`를 선택
- 단지 애노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있다.
  - 이것이 다형성과 DI 컨테이너가 가진 큰 강점이다.
- 웹 스코프가 아니여도 프록시는 사용할 수 있다.

#### 원리

- 스프링 컨테이너는 CGLIB라는 바이트코드를 조작하는 라이브러리를 사용해서 해당 클래스를 상속받은 가짜 프록시 객체를 생성하고 주입한다.
- 가짜 프록시 객체는 실제 요청이 들어오면 진짜 빈을 요청하는 위임 로직이 들어있다.
- 가짜 프록시 객체는 실제 request scope와 관계가 없다. 내부에 단순한 위임 로직만 있고, 싱글톤처럼 동작한다.

#### 주의점

- 싱글톤을 사용하는 것 같지만, 다르게 동작하기 때문에 주의해서 사용해야한다.
- 이런 특별한 scope는 꼭 필요한 곳에 최소화해서 사용해야 한다.
  무분별하게 사용하면 유지보수가 어려워진다.
