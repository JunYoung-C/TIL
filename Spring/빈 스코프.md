# 빈 스코프

스프링은 다음과 같은 다양한 스코프를 지원한다.

- 싱글톤 : 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.
- 프로토타입 : 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프이다.
- 웹 관련 스코프
  - request : 웹 요청이 들어오고 나갈때까지 유지되는 스코프이다.
  - session : 웹 세션이 생성되고 종료될 때까지 유지되는 스코프이다.
  - application : 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프이다.

## 1. 프로토타입 스코프

- 스프링 컨테이너에 요청할 때마다 새로 생성된다.
- 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다.
- 관리할 책임은 빈을 받은 클라이언트에 있다.
- `@PreDestory` 같은 종료 메서드가 호출되지 않는다.

### 1) 싱글톤 빈 요청

1. 싱글톤 스코프의 빈을 스프링 컨테이너에 요청한다.
2. 스프링 컨테이너는 본인이 관리하는 스프링 빈을 반환한다.
3. 이후에 스프링 컨테이너에 같은 요청이 와도 객체 인스턴스의 스프링 빈을 반환한다.

### 2) 프로토타입 빈 요청

1. 프로토탕비 스코프의 빈을 스프링 컨테이너에 요청한다.
2. 스프링 컨테이너는 이 시점에 프로토타입 빈을 생성하고, 필요한 의존관계를 주입한다.
3. 스프링 컨테이너는 생성한 프로토타입 빈을 클라이언트에 반환한다.
4. 이후에 스프링 컨테이너에 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성해서 반환한다.

## 2. 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점

- 싱글톤 빈이 의존관계 주입을 통해서 프로토타입 빈을 주입받아서 사용할 때 문제가 발생한다.
- 이런 경우에는 싱글톤 빈을 사용할 때마다 프로토타입 빈이 새로 생성되지 않는다.
  - 해당 프로토타입 빈은 이미 과거에 주입이 끝났다.
  - 여러 빈에서 같은 프로토타입 빈을 주입받으면, 주입 받는 시점에 각각 새로운 프로토타입 빈이 생성된다.

## 3. 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제 해결

### 1) 스프링 컨테이너에 요청

- 싱글톤 빈이 프로토타입을 사용할 때마다 스프링 컨테이너에 새로 요청한다.

```java
@Autowired
private ApplicationContext ac;

public int logic() {
  PrototypeBean prototypeBean = ac.getBean(PrototypeBean.class);
}
```

- 이처럼 의존관계를 외부에서 주입(DI) 받는 것이 아니라 직접 필요한 의존관계를 찾는 것을 Dependency LookUp(DL), 의존관계 조회(탐색)이라 한다.
- 하지만 이 방법은 스프링 컨테이너에 종속적인 코드가 되고, 단위 테스트도 어려워진다.

### 2) ObjectProvider

- `ObjectProvider`는 필요한 DL 정도의 기능만 제공한다.
- `ObjectFactory`에 편의 기능이 추가되었다.

```java
@Autowired
private ObjectProvider<PrototypeBean> prototypeBeanProvider;

public int logic() {
  PrototypeBean prototypeBean = prototypeBeanProvider.getObject();
}
```

- getObject()를 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다.(DL)
- 스프링이 제공하는 기능을 사용하지만, 기능이 단순하므로 단위테스트를 만들어가 mock 코드를 만들기는 훨씬 쉬워진다.
- 특징
  - ObjectFactory : 기능이 단순. 별도의 라이브버리 필요없음. 스프링에 의존
  - ObjectProvider : ObjectFactory 상속. 옵션, 스트림 처리 등 편의 기능이 많고, 별도의 라이브러리 필요 없음. 스프링에 의존

### 3) JSR-330 Provider

- `javax.inject:javax.inject:1`를 gradle에 추가하면 사용할 수 있다

```java
@Autowired
private Provider<PrototypeBean> provider;

public int logic() {
  PrototypeBean prototypeBean = provider.get();
}
```

- 자바 표준이고, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기는 훨씬 쉬워진다.
- 특징
  - get() 메서드 하나로 기능이 매우 단순하다
  - 별도의 라이브러리가 필요하다.
  - 자바 표준이므로 스프링이 아닌 다른 컨테이너에서도 사용 가능하다.

## 4. 실무에서의 프로토타입 빈

- 매번 사용할 때마다 의존관계 주입이 완료된 새로운 객체가 필요하면 사용한다.
- 싱글톤 빈으로 대부분의 문제를 해결할 수 있기 때문에 프로토타입 빈을 직접적으로 사용하는 일은 매우 드물다.

### Provider과 ObjectProvider의 사용

- ObjectProvider는 DL을 위한 편의 기능을 많이 제공해주고 스프링 외의 별도의 의존관계 추가가 필요 없기 때문에 더 편리하다.
- 만약 스프링이 아닌 다른 컨테이너에서도 사용할 수 있어야 한다면 Provider를 사용한다.
  - 그럴 일은 거의 없다.

## 5. 웹 스코프

- `Scope(value = "request")`와 같이 사용하여 스코프를 지정한다.
- 특징
  - 웹 환경에서만 동작한다.
  - 스프링이 해당 스코프의 종료시점까지 관리한다. 따라서 종료 메서드가 호출된다.
- 종류 : 범위만 다를 뿐 동작 방식은 다 비슷하다.
  - request : HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고 관리된다.
  - session : HTTP Session과 동일한 생명주기를 가지는 스코프
  - application : 서블릿 컨텍스트(ServletContext)와 동일한 생명주기를 가지는 스코프
  - websocket : 웹 소켓과 동일한 생명주기를 가지는 스코프
- request 스코프 빈은 실제 고객 요청이 와야 생성해서 주입할 수 있다. 따라서 필요한 시점까지 객체 조회를 지연해야한다.

## 6. 웹 스코프 - 객제 조회 지연 방법

### 1) Provider / ObjectProvider

- get()이나 getObject()를 호출하는 시점까지 request scope 빈의 생성을 지연할 수 있다.
- 호출하는 시점에는 HTTP 요청이 진행중이므로 request scope 빈의 생성이 정상 처리된다.

### 2) 프록시

![image](https://user-images.githubusercontent.com/87891581/147850805-8a9be5e5-2bd8-48d6-96ee-8ee5917a7f3e.png)

```java
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class MyLogger {
}
```

- 다른 코드의 수정 없이 proxyMode만 추가해주면 된다.
  - 적용 대상이 클래스면 `TARGET_CLASS`를 선택
  - 적용 대상이 인터페이스면 `INTERFACES`를 선택
- 단지 애노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있다.
  - 이것이 다형성과 DI 컨테이너가 가진 큰 강점이다.
- 웹 스코프가 아니여도 프록시는 사용할 수 있다.

#### 원리

- 스프링 컨테이너는 CGLIB라는 바이트코드를 조작하는 라이브러리를 사용해서 해당 클래스를 상속받은 가짜 프록시 객체를 생성하고 주입한다.
- 가짜 프록시 객체는 실제 요청이 들어오면 진짜 빈을 요청하는 위임 로직이 들어있다.
- 가짜 프록시 객체는 실제 request scope와 관계가 없다. 내부에 단순한 위임 로직만 있고, 싱글톤처럼 동작한다.

#### 주의점

- 싱글톤을 사용하는 것 같지만, 다르게 동작하기 때문에 주의해서 사용해야한다.
- 이런 특별한 scope는 꼭 필요한 곳에 최소화해서 사용해야 한다.
  무분별하게 사용하면 유지보수가 어려워진다.
